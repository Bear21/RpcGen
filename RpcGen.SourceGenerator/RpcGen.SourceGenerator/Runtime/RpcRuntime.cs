// <auto-generated/>
#nullable enable
using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net.WebSockets;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace RpcGen
{
   [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
   public sealed class RpcInterfaceAttribute : Attribute
   {
      public RpcInterfaceAttribute(Type outbound, Type inbound) { }
   }
}

internal interface IRpcTransport
{
   Task SendAsync(ReadOnlyMemory<byte> data, CancellationToken cancellationToken);
   IAsyncEnumerable<ReadOnlyMemory<byte>> ReadAsync(CancellationToken cancellationToken);
}

internal sealed class WebSocketTransport : IRpcTransport
{
   private readonly WebSocket _ws;
   public WebSocketTransport(WebSocket ws) => _ws = ws;

   public async Task SendAsync(ReadOnlyMemory<byte> data, CancellationToken ct)
       => await _ws.SendAsync(data, WebSocketMessageType.Text, endOfMessage: true, ct).ConfigureAwait(false);

   public async IAsyncEnumerable<ReadOnlyMemory<byte>> ReadAsync([System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken ct)
   {
      var buffer = new byte[4 * 1024];
      var writer = new ArrayBufferWriter<byte>();

      while (!ct.IsCancellationRequested && _ws.State == WebSocketState.Open)
      {
         writer.Clear();
         WebSocketReceiveResult? rr;
         do
         {
            var seg = new ArraySegment<byte>(buffer);
            rr = await _ws.ReceiveAsync(seg, ct).ConfigureAwait(false);
            if (rr.MessageType == WebSocketMessageType.Close) yield break;
            writer.Write(seg.AsSpan(0, rr.Count));
         }
         while (!rr.EndOfMessage);

         yield return writer.WrittenMemory;
      }
   }
}

internal static class RpcJson
{
   public static readonly JsonSerializerOptions DefaultOptions = new JsonSerializerOptions
   {
      PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
      WriteIndented = false
   };
}

internal enum RpcKind : byte
{
   Request = 0,
   Response = 1,
   Notification = 2
}

public sealed class RpcRemoteException : Exception
{
   public RpcRemoteException(string message) : base(message) { }
}

internal sealed class RpcCore
{
   private long _nextId = 1;
   private readonly ConcurrentDictionary<long, TaskCompletionSource<JsonElement>> _pending = new();
   private readonly JsonSerializerOptions _jsonOptions;

   public RpcCore(JsonSerializerOptions? jsonOptions = null)
       => _jsonOptions = jsonOptions ?? RpcJson.DefaultOptions;

   public JsonSerializerOptions JsonOptions => _jsonOptions;

   public delegate Task<bool> RequestHandler(long id, string iface, string method, JsonElement payload, CancellationToken ct);
   public RequestHandler? Handler { get; set; }

   public async Task RunAsync(IRpcTransport transport, CancellationToken ct = default)
   {
      if (transport is null) throw new ArgumentNullException(nameof(transport));

      await foreach (var msgBytes in transport.ReadAsync(ct).ConfigureAwait(false))
      {
         using var doc = JsonDocument.Parse(msgBytes);
         var root = doc.RootElement;

         var id = root.GetProperty("id").GetInt64();
         var kind = (RpcKind)root.GetProperty("k").GetByte();
         var method = root.GetProperty("m").GetString()!;
         var iface = root.GetProperty("i").GetString()!;
         var hasErr = root.TryGetProperty("err", out var errProp) && errProp.ValueKind != JsonValueKind.Null;
         var payload = root.GetProperty("p");

         if (kind == RpcKind.Response)
         {
            if (_pending.TryRemove(id, out var tcs))
            {
               if (hasErr)
                  tcs.TrySetException(new RpcRemoteException(errProp.GetString() ?? "Remote error"));
               else
                  tcs.TrySetResult(payload.Clone()); // clone to survive after doc disposal
            }
            continue;
         }

         try
         {
            var handled = Handler is not null
                ? await Handler(id, iface, method, payload, ct).ConfigureAwait(false)
                : false;

            if (!handled)
            {
               await SendErrorAsync(transport, id, $"Unknown inbound method '{method}'", iface).ConfigureAwait(false);
            }
         }
         catch (Exception ex)
         {
            await SendErrorAsync(transport, id, ex.Message, iface).ConfigureAwait(false);
         }
      }
   }

   public long NextId() => Interlocked.Increment(ref _nextId);

   public Task<JsonElement> AwaitResponseAsync(long id)
   {
      var tcs = new TaskCompletionSource<JsonElement>(TaskCreationOptions.RunContinuationsAsynchronously);
      if (!_pending.TryAdd(id, tcs))
         throw new InvalidOperationException($"Duplicate request id {id}");
      return tcs.Task;
   }

   public async Task SendRequestAsync(
       IRpcTransport transport,
       string iface,
       string method,
       long id,
       object? payload,
       Type? payloadType,
       bool notification = false,
       CancellationToken ct = default)
   {
      var buffer = new ArrayBufferWriter<byte>();
      using (var writer = new Utf8JsonWriter(buffer))
      {
         writer.WriteStartObject();
         writer.WriteNumber("id", id);
         writer.WriteString("i", iface);
         writer.WriteString("m", method);
         writer.WriteNumber("k", (byte)(notification ? RpcKind.Notification : RpcKind.Request));
         writer.WritePropertyName("p");
         if (payload is null)
         {
            writer.WriteStartObject(); writer.WriteEndObject();
         }
         else
         {
            var json = JsonSerializer.Serialize(payload, payloadType!, _jsonOptions);
            using var payloadDoc = JsonDocument.Parse(json);
            payloadDoc.RootElement.WriteTo(writer);
         }
         writer.WriteEndObject();
         writer.Flush();
      }

      await transport.SendAsync(buffer.WrittenMemory, ct).ConfigureAwait(false);
   }

   public async Task SendResponseAsync(IRpcTransport transport, long id, object? payload, string iface)
   {
      var buffer = new ArrayBufferWriter<byte>();
      using (var writer = new Utf8JsonWriter(buffer))
      {
         writer.WriteStartObject();
         writer.WriteNumber("id", id);
         writer.WriteString("i", iface);
         writer.WriteString("m", "");
         writer.WriteNumber("k", (byte)RpcKind.Response);
         writer.WritePropertyName("p");
         if (payload is null)
         {
            writer.WriteStartObject(); writer.WriteEndObject();
         }
         else
         {
            var json = JsonSerializer.Serialize(payload, payload.GetType(), _jsonOptions);
            using var payloadDoc = JsonDocument.Parse(json);
            payloadDoc.RootElement.WriteTo(writer);
         }
         writer.WriteEndObject();
         writer.Flush();
      }
      await transport.SendAsync(buffer.WrittenMemory, default).ConfigureAwait(false);
   }

   public async Task SendErrorAsync(IRpcTransport transport, long id, string error, string iface)
   {
      var buffer = new ArrayBufferWriter<byte>();
      using (var writer = new Utf8JsonWriter(buffer))
      {
         writer.WriteStartObject();
         writer.WriteNumber("id", id);
         writer.WriteString("i", iface);
         writer.WriteString("m", "");
         writer.WriteNumber("k", (byte)RpcKind.Response);
         writer.WriteString("err", error);
         writer.WritePropertyName("p"); writer.WriteStartObject(); writer.WriteEndObject();
         writer.WriteEndObject();
         writer.Flush();
      }
      await transport.SendAsync(buffer.WrittenMemory, default).ConfigureAwait(false);
   }

   // Convenience for outbound

   public async Task NotifyAsync<TReq>(IRpcTransport transport, string iface, string method, TReq payload, CancellationToken ct = default)
   {
      var id = NextId();
      await SendRequestAsync(transport, iface, method, id, payload!, typeof(TReq), notification: true, ct).ConfigureAwait(false);
   }

   public async Task RequestAsync<TReq>(IRpcTransport transport, string iface, string method, TReq payload, CancellationToken ct = default)
   {
      var id = NextId();
      var wait = AwaitResponseAsync(id);
      await SendRequestAsync(transport, iface, method, id, payload!, typeof(TReq), notification: false, ct).ConfigureAwait(false);
      _ = await wait.ConfigureAwait(false);
   }

   public async Task<TResp?> RequestAsync<TReq, TResp>(IRpcTransport transport, string iface, string method, TReq payload, CancellationToken ct = default)
   {
      var id = NextId();
      var wait = AwaitResponseAsync(id);
      await SendRequestAsync(transport, iface, method, id, payload!, typeof(TReq), notification: false, ct).ConfigureAwait(false);
      JsonElement p = await wait.ConfigureAwait(false);
      return JsonSerializer.Deserialize<TResp>(p.GetRawText(), _jsonOptions);
   }
}
